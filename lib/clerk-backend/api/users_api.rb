=begin
#Clerk Backend API

#The Clerk REST Backend API, meant to be accessed by backend servers.  ### Versions  When the API changes in a way that isn't compatible with older versions, a new version is released. Each version is identified by its release date, e.g. `2021-02-05`. For more information, please see [Clerk API Versions](https://clerk.com/docs/backend-requests/versioning/overview).   Please see https://clerk.com/docs for more information.

The version of the OpenAPI document: v1
Contact: support@clerk.com
Generated by: https://openapi-generator.tech
Generator version: 7.11.0-SNAPSHOT

=end

require 'cgi'

module ClerkBackend
  class UsersApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Ban a user
    # Marks the given user as banned, which means that all their sessions are revoked and they are not allowed to sign in again.
    # @param user_id [String] The ID of the user to ban
    # @param [Hash] opts the optional parameters
    # @return [User]

    def ban(user_id, opts = {})
      data, _status_code, _headers = ban_with_http_info(user_id, opts)
      data
    end

    # Ban a user
    # Marks the given user as banned, which means that all their sessions are revoked and they are not allowed to sign in again.
    # @param user_id [String] The ID of the user to ban
    # @param [Hash] opts the optional parameters
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # POST 
    def ban_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.ban_user ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.ban_user"
      end
      # resource path
      local_var_path = '/users/{user_id}/ban'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.ban_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#ban_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a new user
    # Creates a new user. Your user management settings determine how you should setup your user model.  Any email address and phone number created using this method will be marked as verified.  Note: If you are performing a migration, check out our guide on [zero downtime migrations](https://clerk.com/docs/deployments/migrate-overview).  A rate limit rule of 20 requests per 10 seconds is applied to this endpoint.
    # @param create_user_request [CreateUserRequest] 
    # @param [Hash] opts the optional parameters
    # @return [User]

    def create(create_user_request, opts = {})
      data, _status_code, _headers = create_with_http_info(create_user_request, opts)
      data
    end

    # Create a new user
    # Creates a new user. Your user management settings determine how you should setup your user model.  Any email address and phone number created using this method will be marked as verified.  Note: If you are performing a migration, check out our guide on [zero downtime migrations](https://clerk.com/docs/deployments/migrate-overview).  A rate limit rule of 20 requests per 10 seconds is applied to this endpoint.
    # @param create_user_request [CreateUserRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # POST 
    def create_with_http_info(create_user_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.create_user ...'
      end
      # verify the required parameter 'create_user_request' is set
      if @api_client.config.client_side_validation && create_user_request.nil?
        fail ArgumentError, "Missing the required parameter 'create_user_request' when calling UsersApi.create_user"
      end
      # resource path
      local_var_path = '/users'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_user_request)

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.create_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#create_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a TOTP for a user
    # Creates a TOTP (Time-based One-Time Password) for a given user, returning both the TOTP secret and the URI. 
    # @param user_id [String] The ID of the user for whom the TOTP is being created.
    # @param [Hash] opts the optional parameters
    # @return [TOTP]

    def create_totp(user_id, opts = {})
      data, _status_code, _headers = create_totp_with_http_info(user_id, opts)
      data
    end

    # Create a TOTP for a user
    # Creates a TOTP (Time-based One-Time Password) for a given user, returning both the TOTP secret and the URI. 
    # @param user_id [String] The ID of the user for whom the TOTP is being created.
    # @param [Hash] opts the optional parameters
    # @return [Array<(TOTP, Integer, Hash)>] TOTP data, response status code and response headers
    # POST 
    def create_totp_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.create_user_totp ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.create_user_totp"
      end
      # resource path
      local_var_path = '/users/{user_id}/totp'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TOTP'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.create_user_totp",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#create_user_totp\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Disable all user's Backup codes
    # Disable all of a user's backup codes.
    # @param user_id [String] The ID of the user whose backup codes are to be deleted.
    # @param [Hash] opts the optional parameters
    # @return [DisableMFA200Response]

    def delete_backup_codes(user_id, opts = {})
      data, _status_code, _headers = delete_backup_codes_with_http_info(user_id, opts)
      data
    end

    # Disable all user&#39;s Backup codes
    # Disable all of a user&#39;s backup codes.
    # @param user_id [String] The ID of the user whose backup codes are to be deleted.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DisableMFA200Response, Integer, Hash)>] DisableMFA200Response data, response status code and response headers
    # DELETE 
    def delete_backup_codes_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.delete_backup_code ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.delete_backup_code"
      end
      # resource path
      local_var_path = '/users/{user_id}/backup_code'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DisableMFA200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.delete_backup_code",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#delete_backup_code\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete all the user's TOTPs
    # Deletes all of the user's TOTPs.
    # @param user_id [String] The ID of the user whose TOTPs are to be deleted
    # @param [Hash] opts the optional parameters
    # @return [DisableMFA200Response]

    def delete_totp(user_id, opts = {})
      data, _status_code, _headers = delete_totp_with_http_info(user_id, opts)
      data
    end

    # Delete all the user&#39;s TOTPs
    # Deletes all of the user&#39;s TOTPs.
    # @param user_id [String] The ID of the user whose TOTPs are to be deleted
    # @param [Hash] opts the optional parameters
    # @return [Array<(DisableMFA200Response, Integer, Hash)>] DisableMFA200Response data, response status code and response headers
    # DELETE 
    def delete_totp_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.delete_totp ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.delete_totp"
      end
      # resource path
      local_var_path = '/users/{user_id}/totp'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DisableMFA200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.delete_totp",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#delete_totp\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a user
    # Delete the specified user
    # @param user_id [String] The ID of the user to delete
    # @param [Hash] opts the optional parameters
    # @return [DeletedObject]

    def delete(user_id, opts = {})
      data, _status_code, _headers = delete_with_http_info(user_id, opts)
      data
    end

    # Delete a user
    # Delete the specified user
    # @param user_id [String] The ID of the user to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeletedObject, Integer, Hash)>] DeletedObject data, response status code and response headers
    # DELETE 
    def delete_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.delete_user ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.delete_user"
      end
      # resource path
      local_var_path = '/users/{user_id}'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeletedObject'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.delete_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#delete_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete user profile image
    # Delete a user's profile image
    # @param user_id [String] The ID of the user to delete the profile image for
    # @param [Hash] opts the optional parameters
    # @return [User]

    def delete_profile_image(user_id, opts = {})
      data, _status_code, _headers = delete_profile_image_with_http_info(user_id, opts)
      data
    end

    # Delete user profile image
    # Delete a user&#39;s profile image
    # @param user_id [String] The ID of the user to delete the profile image for
    # @param [Hash] opts the optional parameters
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # DELETE 
    def delete_profile_image_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.delete_user_profile_image ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.delete_user_profile_image"
      end
      # resource path
      local_var_path = '/users/{user_id}/profile_image'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.delete_user_profile_image",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#delete_user_profile_image\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Disable a user's MFA methods
    # Disable all of a user's MFA methods (e.g. OTP sent via SMS, TOTP on their authenticator app) at once.
    # @param user_id [String] The ID of the user whose MFA methods are to be disabled
    # @param [Hash] opts the optional parameters
    # @return [DisableMFA200Response]

    def disable_mfa(user_id, opts = {})
      data, _status_code, _headers = disable_mfa_with_http_info(user_id, opts)
      data
    end

    # Disable a user&#39;s MFA methods
    # Disable all of a user&#39;s MFA methods (e.g. OTP sent via SMS, TOTP on their authenticator app) at once.
    # @param user_id [String] The ID of the user whose MFA methods are to be disabled
    # @param [Hash] opts the optional parameters
    # @return [Array<(DisableMFA200Response, Integer, Hash)>] DisableMFA200Response data, response status code and response headers
    # DELETE 
    def disable_mfa_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.disable_mfa ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.disable_mfa"
      end
      # resource path
      local_var_path = '/users/{user_id}/mfa'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DisableMFA200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.disable_mfa",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#disable_mfa\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve the OAuth access token of a user
    # Fetch the corresponding OAuth access token for a user that has previously authenticated with a particular OAuth provider. For OAuth 2.0, if the access token has expired and we have a corresponding refresh token, the access token will be refreshed transparently the new one will be returned.
    # @param user_id [String] The ID of the user for which to retrieve the OAuth access token
    # @param provider [String] The ID of the OAuth provider (e.g. &#x60;oauth_google&#x60;)
    # @param [Hash] opts the optional parameters
    # @return [Array<GetOAuthAccessToken200ResponseInner>]

    def oauth_access_token(user_id, provider, opts = {})
      data, _status_code, _headers = oauth_access_token_with_http_info(user_id, provider, opts)
      data
    end

    # Retrieve the OAuth access token of a user
    # Fetch the corresponding OAuth access token for a user that has previously authenticated with a particular OAuth provider. For OAuth 2.0, if the access token has expired and we have a corresponding refresh token, the access token will be refreshed transparently the new one will be returned.
    # @param user_id [String] The ID of the user for which to retrieve the OAuth access token
    # @param provider [String] The ID of the OAuth provider (e.g. &#x60;oauth_google&#x60;)
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<GetOAuthAccessToken200ResponseInner>, Integer, Hash)>] Array<GetOAuthAccessToken200ResponseInner> data, response status code and response headers
    # GET array
    def oauth_access_token_with_http_info(user_id, provider, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_o_auth_access_token ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.get_o_auth_access_token"
      end
      # verify the required parameter 'provider' is set
      if @api_client.config.client_side_validation && provider.nil?
        fail ArgumentError, "Missing the required parameter 'provider' when calling UsersApi.get_o_auth_access_token"
      end
      # resource path
      local_var_path = '/users/{user_id}/oauth_access_tokens/{provider}'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s)).sub('{' + 'provider' + '}', CGI.escape(provider.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<GetOAuthAccessToken200ResponseInner>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.get_o_auth_access_token",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_o_auth_access_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a user
    # Retrieve the details of a user
    # @param user_id [String] The ID of the user to retrieve
    # @param [Hash] opts the optional parameters
    # @return [User]

    def find(user_id, opts = {})
      data, _status_code, _headers = find_with_http_info(user_id, opts)
      data
    end

    # Retrieve a user
    # Retrieve the details of a user
    # @param user_id [String] The ID of the user to retrieve
    # @param [Hash] opts the optional parameters
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # GET 
    def find_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_user ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.get_user"
      end
      # resource path
      local_var_path = '/users/{user_id}'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.get_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List all users
    # Returns a list of all users. The users are returned sorted by creation date, with the newest users appearing first.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :email_address Returns users with the specified email addresses. Accepts up to 100 email addresses. Any email addresses not found are ignored.
    # @option opts [Array<String>] :phone_number Returns users with the specified phone numbers. Accepts up to 100 phone numbers. Any phone numbers not found are ignored.
    # @option opts [Array<String>] :external_id Returns users with the specified external ids. For each external id, the &#x60;+&#x60; and &#x60;-&#x60; can be prepended to the id, which denote whether the respective external id should be included or excluded from the result set. Accepts up to 100 external ids. Any external ids not found are ignored.
    # @option opts [Array<String>] :username Returns users with the specified usernames. Accepts up to 100 usernames. Any usernames not found are ignored.
    # @option opts [Array<String>] :web3_wallet Returns users with the specified web3 wallet addresses. Accepts up to 100 web3 wallet addresses. Any web3 wallet addressed not found are ignored.
    # @option opts [Array<String>] :user_id Returns users with the user ids specified. For each user id, the &#x60;+&#x60; and &#x60;-&#x60; can be prepended to the id, which denote whether the respective user id should be included or excluded from the result set. Accepts up to 100 user ids. Any user ids not found are ignored.
    # @option opts [Array<String>] :organization_id Returns users that have memberships to the given organizations. For each organization id, the &#x60;+&#x60; and &#x60;-&#x60; can be prepended to the id, which denote whether the respective organization should be included or excluded from the result set. Accepts up to 100 organization ids.
    # @option opts [String] :query Returns users that match the given query. For possible matches, we check the email addresses, phone numbers, usernames, web3 wallets, user ids, first and last names. The query value doesn&#39;t need to match the exact value you are looking for, it is capable of partial matches as well.
    # @option opts [Integer] :last_active_at_since Returns users that had session activity since the given date, with day precision. Providing a value with higher precision than day will result in an error. Example: use 1700690400000 to retrieve users that had session activity from 2023-11-23 until the current day.
    # @option opts [Float] :limit Applies a limit to the number of results returned. Can be used for paginating the results together with &#x60;offset&#x60;. (default to 10)
    # @option opts [Float] :offset Skip the first &#x60;offset&#x60; results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with &#x60;limit&#x60;. (default to 0)
    # @option opts [String] :order_by Allows to return users in a particular order. At the moment, you can order the returned users by their &#x60;created_at&#x60;,&#x60;updated_at&#x60;,&#x60;email_address&#x60;,&#x60;web3wallet&#x60;,&#x60;first_name&#x60;,&#x60;last_name&#x60;,&#x60;phone_number&#x60;,&#x60;username&#x60;,&#x60;last_active_at&#x60;,&#x60;last_sign_in_at&#x60;. In order to specify the direction, you can use the &#x60;+/-&#x60; symbols prepended in the property to order by. For example, if you want users to be returned in descending order according to their &#x60;created_at&#x60; property, you can use &#x60;-created_at&#x60;. If you don&#39;t use &#x60;+&#x60; or &#x60;-&#x60;, then &#x60;+&#x60; is implied. We only support one &#x60;order_by&#x60; parameter, and if multiple &#x60;order_by&#x60; parameters are provided, we will only keep the first one. For example, if you pass &#x60;order_by&#x3D;username&amp;order_by&#x3D;created_at&#x60;, we will consider only the first &#x60;order_by&#x60; parameter, which is &#x60;username&#x60;. The &#x60;created_at&#x60; parameter will be ignored in this case. (default to '-created_at')
    # @return [Array<User>]

    def all(opts = {})
      data, _status_code, _headers = all_with_http_info(opts)
      data
    end

    # List all users
    # Returns a list of all users. The users are returned sorted by creation date, with the newest users appearing first.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :email_address Returns users with the specified email addresses. Accepts up to 100 email addresses. Any email addresses not found are ignored.
    # @option opts [Array<String>] :phone_number Returns users with the specified phone numbers. Accepts up to 100 phone numbers. Any phone numbers not found are ignored.
    # @option opts [Array<String>] :external_id Returns users with the specified external ids. For each external id, the &#x60;+&#x60; and &#x60;-&#x60; can be prepended to the id, which denote whether the respective external id should be included or excluded from the result set. Accepts up to 100 external ids. Any external ids not found are ignored.
    # @option opts [Array<String>] :username Returns users with the specified usernames. Accepts up to 100 usernames. Any usernames not found are ignored.
    # @option opts [Array<String>] :web3_wallet Returns users with the specified web3 wallet addresses. Accepts up to 100 web3 wallet addresses. Any web3 wallet addressed not found are ignored.
    # @option opts [Array<String>] :user_id Returns users with the user ids specified. For each user id, the &#x60;+&#x60; and &#x60;-&#x60; can be prepended to the id, which denote whether the respective user id should be included or excluded from the result set. Accepts up to 100 user ids. Any user ids not found are ignored.
    # @option opts [Array<String>] :organization_id Returns users that have memberships to the given organizations. For each organization id, the &#x60;+&#x60; and &#x60;-&#x60; can be prepended to the id, which denote whether the respective organization should be included or excluded from the result set. Accepts up to 100 organization ids.
    # @option opts [String] :query Returns users that match the given query. For possible matches, we check the email addresses, phone numbers, usernames, web3 wallets, user ids, first and last names. The query value doesn&#39;t need to match the exact value you are looking for, it is capable of partial matches as well.
    # @option opts [Integer] :last_active_at_since Returns users that had session activity since the given date, with day precision. Providing a value with higher precision than day will result in an error. Example: use 1700690400000 to retrieve users that had session activity from 2023-11-23 until the current day.
    # @option opts [Float] :limit Applies a limit to the number of results returned. Can be used for paginating the results together with &#x60;offset&#x60;. (default to 10)
    # @option opts [Float] :offset Skip the first &#x60;offset&#x60; results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with &#x60;limit&#x60;. (default to 0)
    # @option opts [String] :order_by Allows to return users in a particular order. At the moment, you can order the returned users by their &#x60;created_at&#x60;,&#x60;updated_at&#x60;,&#x60;email_address&#x60;,&#x60;web3wallet&#x60;,&#x60;first_name&#x60;,&#x60;last_name&#x60;,&#x60;phone_number&#x60;,&#x60;username&#x60;,&#x60;last_active_at&#x60;,&#x60;last_sign_in_at&#x60;. In order to specify the direction, you can use the &#x60;+/-&#x60; symbols prepended in the property to order by. For example, if you want users to be returned in descending order according to their &#x60;created_at&#x60; property, you can use &#x60;-created_at&#x60;. If you don&#39;t use &#x60;+&#x60; or &#x60;-&#x60;, then &#x60;+&#x60; is implied. We only support one &#x60;order_by&#x60; parameter, and if multiple &#x60;order_by&#x60; parameters are provided, we will only keep the first one. For example, if you pass &#x60;order_by&#x3D;username&amp;order_by&#x3D;created_at&#x60;, we will consider only the first &#x60;order_by&#x60; parameter, which is &#x60;username&#x60;. The &#x60;created_at&#x60; parameter will be ignored in this case. (default to '-created_at')
    # @return [Array<(Array<User>, Integer, Hash)>] Array<User> data, response status code and response headers
    # GET array
    def all_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_user_list ...'
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling UsersApi.get_user_list, must be smaller than or equal to 500.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling UsersApi.get_user_list, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling UsersApi.get_user_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/users'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'email_address'] = @api_client.build_collection_param(opts[:'email_address'], :multi) if !opts[:'email_address'].nil?
      query_params[:'phone_number'] = @api_client.build_collection_param(opts[:'phone_number'], :multi) if !opts[:'phone_number'].nil?
      query_params[:'external_id'] = @api_client.build_collection_param(opts[:'external_id'], :multi) if !opts[:'external_id'].nil?
      query_params[:'username'] = @api_client.build_collection_param(opts[:'username'], :multi) if !opts[:'username'].nil?
      query_params[:'web3_wallet'] = @api_client.build_collection_param(opts[:'web3_wallet'], :multi) if !opts[:'web3_wallet'].nil?
      query_params[:'user_id'] = @api_client.build_collection_param(opts[:'user_id'], :multi) if !opts[:'user_id'].nil?
      query_params[:'organization_id'] = @api_client.build_collection_param(opts[:'organization_id'], :multi) if !opts[:'organization_id'].nil?
      query_params[:'query'] = opts[:'query'] if !opts[:'query'].nil?
      query_params[:'last_active_at_since'] = opts[:'last_active_at_since'] if !opts[:'last_active_at_since'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'order_by'] = opts[:'order_by'] if !opts[:'order_by'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<User>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.get_user_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_user_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Count users
    # Returns a total count of all users that match the given filtering criteria.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :email_address Counts users with the specified email addresses. Accepts up to 100 email addresses. Any email addresses not found are ignored.
    # @option opts [Array<String>] :phone_number Counts users with the specified phone numbers. Accepts up to 100 phone numbers. Any phone numbers not found are ignored.
    # @option opts [Array<String>] :external_id Counts users with the specified external ids. Accepts up to 100 external ids. Any external ids not found are ignored.
    # @option opts [Array<String>] :username Counts users with the specified usernames. Accepts up to 100 usernames. Any usernames not found are ignored.
    # @option opts [Array<String>] :web3_wallet Counts users with the specified web3 wallet addresses. Accepts up to 100 web3 wallet addresses. Any web3 wallet addressed not found are ignored.
    # @option opts [Array<String>] :user_id Counts users with the user ids specified. Accepts up to 100 user ids. Any user ids not found are ignored.
    # @option opts [String] :query Counts users that match the given query. For possible matches, we check the email addresses, phone numbers, usernames, web3 wallets, user ids, first and last names. The query value doesn&#39;t need to match the exact value you are looking for, it is capable of partial matches as well.
    # @return [TotalCount]

    def count(opts = {})
      data, _status_code, _headers = count_with_http_info(opts)
      data
    end

    # Count users
    # Returns a total count of all users that match the given filtering criteria.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :email_address Counts users with the specified email addresses. Accepts up to 100 email addresses. Any email addresses not found are ignored.
    # @option opts [Array<String>] :phone_number Counts users with the specified phone numbers. Accepts up to 100 phone numbers. Any phone numbers not found are ignored.
    # @option opts [Array<String>] :external_id Counts users with the specified external ids. Accepts up to 100 external ids. Any external ids not found are ignored.
    # @option opts [Array<String>] :username Counts users with the specified usernames. Accepts up to 100 usernames. Any usernames not found are ignored.
    # @option opts [Array<String>] :web3_wallet Counts users with the specified web3 wallet addresses. Accepts up to 100 web3 wallet addresses. Any web3 wallet addressed not found are ignored.
    # @option opts [Array<String>] :user_id Counts users with the user ids specified. Accepts up to 100 user ids. Any user ids not found are ignored.
    # @option opts [String] :query Counts users that match the given query. For possible matches, we check the email addresses, phone numbers, usernames, web3 wallets, user ids, first and last names. The query value doesn&#39;t need to match the exact value you are looking for, it is capable of partial matches as well.
    # @return [Array<(TotalCount, Integer, Hash)>] TotalCount data, response status code and response headers
    # GET 
    def count_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.get_users_count ...'
      end
      # resource path
      local_var_path = '/users/count'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'email_address'] = @api_client.build_collection_param(opts[:'email_address'], :multi) if !opts[:'email_address'].nil?
      query_params[:'phone_number'] = @api_client.build_collection_param(opts[:'phone_number'], :multi) if !opts[:'phone_number'].nil?
      query_params[:'external_id'] = @api_client.build_collection_param(opts[:'external_id'], :multi) if !opts[:'external_id'].nil?
      query_params[:'username'] = @api_client.build_collection_param(opts[:'username'], :multi) if !opts[:'username'].nil?
      query_params[:'web3_wallet'] = @api_client.build_collection_param(opts[:'web3_wallet'], :multi) if !opts[:'web3_wallet'].nil?
      query_params[:'user_id'] = @api_client.build_collection_param(opts[:'user_id'], :multi) if !opts[:'user_id'].nil?
      query_params[:'query'] = opts[:'query'] if !opts[:'query'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TotalCount'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.get_users_count",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#get_users_count\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Lock a user
    # Marks the given user as locked, which means they are not allowed to sign in again until the lock expires. Lock duration can be configured in the instance's restrictions settings.
    # @param user_id [String] The ID of the user to lock
    # @param [Hash] opts the optional parameters
    # @return [User]

    def lock(user_id, opts = {})
      data, _status_code, _headers = lock_with_http_info(user_id, opts)
      data
    end

    # Lock a user
    # Marks the given user as locked, which means they are not allowed to sign in again until the lock expires. Lock duration can be configured in the instance&#39;s restrictions settings.
    # @param user_id [String] The ID of the user to lock
    # @param [Hash] opts the optional parameters
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # POST 
    def lock_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.lock_user ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.lock_user"
      end
      # resource path
      local_var_path = '/users/{user_id}/lock'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.lock_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#lock_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Set user profile image
    # Update a user's profile image
    # @param user_id [String] The ID of the user to update the profile image for
    # @param [Hash] opts the optional parameters
    # @option opts [File] :file 
    # @return [User]

    def update_profile_image(user_id, opts = {})
      data, _status_code, _headers = update_profile_image_with_http_info(user_id, opts)
      data
    end

    # Set user profile image
    # Update a user&#39;s profile image
    # @param user_id [String] The ID of the user to update the profile image for
    # @param [Hash] opts the optional parameters
    # @option opts [File] :file 
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # POST 
    def update_profile_image_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.set_user_profile_image ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.set_user_profile_image"
      end
      # resource path
      local_var_path = '/users/{user_id}/profile_image'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['multipart/form-data'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['file'] = opts[:'file'] if !opts[:'file'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.set_user_profile_image",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#set_user_profile_image\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unban a user
    # Removes the ban mark from the given user.
    # @param user_id [String] The ID of the user to unban
    # @param [Hash] opts the optional parameters
    # @return [User]

    def unban(user_id, opts = {})
      data, _status_code, _headers = unban_with_http_info(user_id, opts)
      data
    end

    # Unban a user
    # Removes the ban mark from the given user.
    # @param user_id [String] The ID of the user to unban
    # @param [Hash] opts the optional parameters
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # POST 
    def unban_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.unban_user ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.unban_user"
      end
      # resource path
      local_var_path = '/users/{user_id}/unban'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.unban_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#unban_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unlock a user
    # Removes the lock from the given user.
    # @param user_id [String] The ID of the user to unlock
    # @param [Hash] opts the optional parameters
    # @return [User]

    def unlock(user_id, opts = {})
      data, _status_code, _headers = unlock_with_http_info(user_id, opts)
      data
    end

    # Unlock a user
    # Removes the lock from the given user.
    # @param user_id [String] The ID of the user to unlock
    # @param [Hash] opts the optional parameters
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # POST 
    def unlock_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.unlock_user ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.unlock_user"
      end
      # resource path
      local_var_path = '/users/{user_id}/unlock'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.unlock_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#unlock_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a user
    # Update a user's attributes.  You can set the user's primary contact identifiers (email address and phone numbers) by updating the `primary_email_address_id` and `primary_phone_number_id` attributes respectively. Both IDs should correspond to verified identifications that belong to the user.  You can remove a user's username by setting the username attribute to null or the blank string \"\". This is a destructive action; the identification will be deleted forever. Usernames can be removed only if they are optional in your instance settings and there's at least one other identifier which can be used for authentication.  This endpoint allows changing a user's password. When passing the `password` parameter directly you have two further options. You can ignore the password policy checks for your instance by setting the `skip_password_checks` parameter to `true`. You can also choose to sign the user out of all their active sessions on any device once the password is updated. Just set `sign_out_of_other_sessions` to `true`.
    # @param user_id [String] The ID of the user to update
    # @param update_user_request [UpdateUserRequest] 
    # @param [Hash] opts the optional parameters
    # @return [User]

    def update(user_id, update_user_request, opts = {})
      data, _status_code, _headers = update_with_http_info(user_id, update_user_request, opts)
      data
    end

    # Update a user
    # Update a user&#39;s attributes.  You can set the user&#39;s primary contact identifiers (email address and phone numbers) by updating the &#x60;primary_email_address_id&#x60; and &#x60;primary_phone_number_id&#x60; attributes respectively. Both IDs should correspond to verified identifications that belong to the user.  You can remove a user&#39;s username by setting the username attribute to null or the blank string \&quot;\&quot;. This is a destructive action; the identification will be deleted forever. Usernames can be removed only if they are optional in your instance settings and there&#39;s at least one other identifier which can be used for authentication.  This endpoint allows changing a user&#39;s password. When passing the &#x60;password&#x60; parameter directly you have two further options. You can ignore the password policy checks for your instance by setting the &#x60;skip_password_checks&#x60; parameter to &#x60;true&#x60;. You can also choose to sign the user out of all their active sessions on any device once the password is updated. Just set &#x60;sign_out_of_other_sessions&#x60; to &#x60;true&#x60;.
    # @param user_id [String] The ID of the user to update
    # @param update_user_request [UpdateUserRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # PATCH 
    def update_with_http_info(user_id, update_user_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.update_user ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.update_user"
      end
      # verify the required parameter 'update_user_request' is set
      if @api_client.config.client_side_validation && update_user_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_user_request' when calling UsersApi.update_user"
      end
      # resource path
      local_var_path = '/users/{user_id}'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_user_request)

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.update_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#update_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Merge and update a user's metadata
    # Update a user's metadata attributes by merging existing values with the provided parameters.  This endpoint behaves differently than the *Update a user* endpoint. Metadata values will not be replaced entirely. Instead, a deep merge will be performed. Deep means that any nested JSON objects will be merged as well.  You can remove metadata keys at any level by setting their value to `null`.
    # @param user_id [String] The ID of the user whose metadata will be updated and merged
    # @param [Hash] opts the optional parameters
    # @option opts [UpdateUserMetadataRequest] :update_user_metadata_request 
    # @return [User]

    def metadata(user_id, opts = {})
      data, _status_code, _headers = metadata_with_http_info(user_id, opts)
      data
    end

    # Merge and update a user&#39;s metadata
    # Update a user&#39;s metadata attributes by merging existing values with the provided parameters.  This endpoint behaves differently than the *Update a user* endpoint. Metadata values will not be replaced entirely. Instead, a deep merge will be performed. Deep means that any nested JSON objects will be merged as well.  You can remove metadata keys at any level by setting their value to &#x60;null&#x60;.
    # @param user_id [String] The ID of the user whose metadata will be updated and merged
    # @param [Hash] opts the optional parameters
    # @option opts [UpdateUserMetadataRequest] :update_user_metadata_request 
    # @return [Array<(User, Integer, Hash)>] User data, response status code and response headers
    # PATCH 
    def metadata_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.update_user_metadata ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.update_user_metadata"
      end
      # resource path
      local_var_path = '/users/{user_id}/metadata'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'update_user_metadata_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'User'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.update_user_metadata",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#update_user_metadata\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a user passkey
    # Delete the passkey identification for a given user and notify them through email.
    # @param user_id [String] The ID of the user that owns the passkey identity
    # @param passkey_identification_id [String] The ID of the passkey identity to be deleted
    # @param [Hash] opts the optional parameters
    # @return [DeletedObject]

    def delete_passkey(user_id, passkey_identification_id, opts = {})
      data, _status_code, _headers = delete_passkey_with_http_info(user_id, passkey_identification_id, opts)
      data
    end

    # Delete a user passkey
    # Delete the passkey identification for a given user and notify them through email.
    # @param user_id [String] The ID of the user that owns the passkey identity
    # @param passkey_identification_id [String] The ID of the passkey identity to be deleted
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeletedObject, Integer, Hash)>] DeletedObject data, response status code and response headers
    # DELETE 
    def delete_passkey_with_http_info(user_id, passkey_identification_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.user_passkey_delete ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.user_passkey_delete"
      end
      # verify the required parameter 'passkey_identification_id' is set
      if @api_client.config.client_side_validation && passkey_identification_id.nil?
        fail ArgumentError, "Missing the required parameter 'passkey_identification_id' when calling UsersApi.user_passkey_delete"
      end
      # resource path
      local_var_path = '/users/{user_id}/passkeys/{passkey_identification_id}'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s)).sub('{' + 'passkey_identification_id' + '}', CGI.escape(passkey_identification_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeletedObject'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.user_passkey_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#user_passkey_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a user web3 wallet
    # Delete the web3 wallet identification for a given user.
    # @param user_id [String] The ID of the user that owns the web3 wallet
    # @param web3_wallet_identification_id [String] The ID of the web3 wallet identity to be deleted
    # @param [Hash] opts the optional parameters
    # @return [DeletedObject]

    def delete_web3_wallet(user_id, web3_wallet_identification_id, opts = {})
      data, _status_code, _headers = delete_web3_wallet_with_http_info(user_id, web3_wallet_identification_id, opts)
      data
    end

    # Delete a user web3 wallet
    # Delete the web3 wallet identification for a given user.
    # @param user_id [String] The ID of the user that owns the web3 wallet
    # @param web3_wallet_identification_id [String] The ID of the web3 wallet identity to be deleted
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeletedObject, Integer, Hash)>] DeletedObject data, response status code and response headers
    # DELETE 
    def delete_web3_wallet_with_http_info(user_id, web3_wallet_identification_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.user_web3_wallet_delete ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.user_web3_wallet_delete"
      end
      # verify the required parameter 'web3_wallet_identification_id' is set
      if @api_client.config.client_side_validation && web3_wallet_identification_id.nil?
        fail ArgumentError, "Missing the required parameter 'web3_wallet_identification_id' when calling UsersApi.user_web3_wallet_delete"
      end
      # resource path
      local_var_path = '/users/{user_id}/web3_wallets/{web3_wallet_identification_id}'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s)).sub('{' + 'web3_wallet_identification_id' + '}', CGI.escape(web3_wallet_identification_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'DeletedObject'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.user_web3_wallet_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#user_web3_wallet_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve all memberships for a user
    # Retrieve a paginated list of the user's organization memberships
    # @param user_id [String] The ID of the user whose organization memberships we want to retrieve
    # @param [Hash] opts the optional parameters
    # @option opts [Float] :limit Applies a limit to the number of results returned. Can be used for paginating the results together with &#x60;offset&#x60;. (default to 10)
    # @option opts [Float] :offset Skip the first &#x60;offset&#x60; results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with &#x60;limit&#x60;. (default to 0)
    # @return [OrganizationMemberships]

    def organization_memberships(user_id, opts = {})
      data, _status_code, _headers = organization_memberships_with_http_info(user_id, opts)
      data
    end

    # Retrieve all memberships for a user
    # Retrieve a paginated list of the user&#39;s organization memberships
    # @param user_id [String] The ID of the user whose organization memberships we want to retrieve
    # @param [Hash] opts the optional parameters
    # @option opts [Float] :limit Applies a limit to the number of results returned. Can be used for paginating the results together with &#x60;offset&#x60;. (default to 10)
    # @option opts [Float] :offset Skip the first &#x60;offset&#x60; results when paginating. Needs to be an integer greater or equal to zero. To be used in conjunction with &#x60;limit&#x60;. (default to 0)
    # @return [Array<(OrganizationMemberships, Integer, Hash)>] OrganizationMemberships data, response status code and response headers
    # GET 
    def organization_memberships_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.users_get_organization_memberships ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.users_get_organization_memberships"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 500
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling UsersApi.users_get_organization_memberships, must be smaller than or equal to 500.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling UsersApi.users_get_organization_memberships, must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling UsersApi.users_get_organization_memberships, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/users/{user_id}/organization_memberships'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OrganizationMemberships'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.users_get_organization_memberships",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#users_get_organization_memberships\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Verify the password of a user
    # Check that the user's password matches the supplied input. Useful for custom auth flows and re-verification.
    # @param user_id [String] The ID of the user for whom to verify the password
    # @param [Hash] opts the optional parameters
    # @option opts [VerifyPasswordRequest] :verify_password_request 
    # @return [VerifyPassword200Response]

    def verify_password(user_id, opts = {})
      data, _status_code, _headers = verify_password_with_http_info(user_id, opts)
      data
    end

    # Verify the password of a user
    # Check that the user&#39;s password matches the supplied input. Useful for custom auth flows and re-verification.
    # @param user_id [String] The ID of the user for whom to verify the password
    # @param [Hash] opts the optional parameters
    # @option opts [VerifyPasswordRequest] :verify_password_request 
    # @return [Array<(VerifyPassword200Response, Integer, Hash)>] VerifyPassword200Response data, response status code and response headers
    # POST 
    def verify_password_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.verify_password ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.verify_password"
      end
      # resource path
      local_var_path = '/users/{user_id}/verify_password'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'verify_password_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'VerifyPassword200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.verify_password",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#verify_password\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Verify a TOTP or backup code for a user
    # Verify that the provided TOTP or backup code is valid for the user. Verifying a backup code will result it in being consumed (i.e. it will become invalid). Useful for custom auth flows and re-verification.
    # @param user_id [String] The ID of the user for whom to verify the TOTP
    # @param [Hash] opts the optional parameters
    # @option opts [VerifyTOTPRequest] :verify_totp_request 
    # @return [VerifyTOTP200Response]

    def verify_totp(user_id, opts = {})
      data, _status_code, _headers = verify_totp_with_http_info(user_id, opts)
      data
    end

    # Verify a TOTP or backup code for a user
    # Verify that the provided TOTP or backup code is valid for the user. Verifying a backup code will result it in being consumed (i.e. it will become invalid). Useful for custom auth flows and re-verification.
    # @param user_id [String] The ID of the user for whom to verify the TOTP
    # @param [Hash] opts the optional parameters
    # @option opts [VerifyTOTPRequest] :verify_totp_request 
    # @return [Array<(VerifyTOTP200Response, Integer, Hash)>] VerifyTOTP200Response data, response status code and response headers
    # POST 
    def verify_totp_with_http_info(user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UsersApi.verify_totp ...'
      end
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        fail ArgumentError, "Missing the required parameter 'user_id' when calling UsersApi.verify_totp"
      end
      # resource path
      local_var_path = '/users/{user_id}/verify_totp'.sub('{' + 'user_id' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'verify_totp_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'VerifyTOTP200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"UsersApi.verify_totp",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UsersApi#verify_totp\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
